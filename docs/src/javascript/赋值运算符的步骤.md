---
date: 2025-10-02 18:46:34
title: 赋值运算符的步骤
permalink: /pages/61a20e
categories:
  - src
  - javascript
---

# 赋值运算符的步骤详解

在 JavaScript 中，赋值运算符（=）是最常用的运算符之一。理解其内部执行步骤对于掌握 JavaScript 的变量机制和内存管理非常重要。

## 基本示例

```javascript
var a;
a = 1;
```

## 赋值运算符的执行步骤

赋值运算符的执行过程可以分为以下几个步骤：

### 1. 查找变量的内存地址
首先，JavaScript 引擎会在作用域中查找变量 `a` 的内存地址，为后续的赋值操作做准备。

```
作用域链查找
┌─────────────┐
│   Global    │
│             │
│   a: null   │ ← 找到变量a的位置
└─────────────┘
```

### 2. 计算右侧表达式的值
计算赋值运算符右侧表达式的值，在这个例子中是字面量 `1`。

```
表达式计算
┌─────────────┐
│  右侧代码   │
│             │
│     1       │ → 计算结果: 1
└─────────────┘
```

### 3. 将值存储到变量的内存位置
将计算得到的值存储到步骤1中找到的变量内存地址中。

```
内存存储过程
┌─────────────┐    ┌─────────────┐
│   变量a     │    │    值1      │
│             │ ←  │             │
│  内存地址   │    │   数据1     │
└─────────────┘    └─────────────┘
```

### 4. 返回赋值后的值
赋值操作完成后，返回右侧表达式计算得到的值，这就是为什么赋值表达式本身也有返回值。

```javascript
var a;
var b = (a = 1); // b 的值是 1，因为 a = 1 这个表达式的返回值是 1
console.log(a); // 1
console.log(b); // 1
```

## 更复杂的赋值示例

### 示例1：表达式计算
```javascript
var x;
x = 2 + 3 * 4; // 右侧先进行运算: 2 + 12 = 14
```

执行步骤：
1. 查找变量 `x` 的内存地址
2. 计算右侧表达式 `2 + 3 * 4`：
   - 先计算 `3 * 4 = 12`
   - 再计算 `2 + 12 = 14`
3. 将结果 `14` 存储到变量 `x` 的内存位置
4. 返回值 `14`

### 示例2：变量赋值
```javascript
var a = 5;
var b;
b = a; // 将变量a的值赋给变量b
```

执行步骤：
1. 查找变量 `b` 的内存地址
2. 获取右侧变量 `a` 的值（需要先查找 `a` 的内存地址，然后读取值）
3. 将获取到的值 `5` 存储到变量 `b` 的内存位置
4. 返回值 `5`

## 内存示意图

```
执行 var a; 后的内存状态:
┌─────────────┬─────────────┐
│   变量名    │     值      │
├─────────────┼─────────────┤
│      a      │    null     │
└─────────────┴─────────────┘

执行 a = 1; 后的内存状态:
┌─────────────┬─────────────┐
│   变量名    │     值      │
├─────────────┼─────────────┤
│      a      │      1      │
└─────────────┴─────────────┘
```

## 链式赋值

JavaScript 还支持链式赋值：

```javascript
var a, b, c;
a = b = c = 10;
```

执行过程：
1. 先计算最右边的表达式 `10`
2. 将 `10` 赋值给 `c`
3. 将 `c = 10` 表达式的返回值赋给 `b`
4. 将 `b = 10` 表达式的返回值赋给 `a`

最终结果是三个变量都指向值 `10`。

## 注意事项

1. **变量提升**：使用 `var` 声明的变量会被提升，但赋值不会被提升
2. **引用类型**：对于对象和数组，赋值的是引用而非值本身
3. **作用域**：赋值操作会在当前作用域中查找变量

## 复杂示例：对象引用与链式赋值

下面是一个较为复杂的示例，可以帮助我们更好地理解对象引用和赋值运算符的执行顺序：

```javascript
var a = {n: 1};
var b = a;
a.x = a = {n: 2};
console.log(a.x); // undefined
console.log(b.x); // {n: 2}
```

这个示例的执行过程比较复杂，让我们逐步分析：

### 第一步：初始化对象
```javascript
var a = {n: 1};
var b = a;
```

此时内存中的状态如下：
![赋值运算符_img1](/img/javascript/赋值运算符的步骤/赋值运算符_img1.jpg)
### 第二步：执行复杂赋值
```javascript
a.x = a = {n: 2};
```

这是关键的一步，我们需要按照赋值运算符的执行步骤来分析：

1. **左侧表达式求值**：首先计算 `a.x` 中的 `a`，得到对 `{n: 1}` 对象的引用
2. **右侧表达式求值**：计算 `a = {n: 2}`：
   - 创建新对象 `{n: 2}`
   - 将变量 `a` 指向这个新对象
   - 表达式返回新对象 `{n: 2}` 的引用
3. **完成赋值**：将右侧表达式的返回值（即 `{n: 2}` 的引用）赋给第一步中确定的对象属性 `x`

最终内存状态如下：
![赋值运算符_img2](/img/javascript/赋值运算符的步骤/赋值运算符_img2.jpg)

说明：
- `a` 直接指向新创建的对象 `{n: 2}`
- `b` 仍然指向原来的对象 `{n: 1}`
- 原来对象的 `x` 属性指向同一个新对象 `{n: 2}`
- 因此，`a` 和 `b.x` 实际上指向的是内存中的同一个对象

### 结果分析

- `a.x` 为 `undefined`，因为 `a` 现在指向新对象 `{n: 2}`，而这个对象没有 `x` 属性
- `b.x` 为 `{n: 2}`，因为 `b` 仍然指向原来的对象 `{n: 1}`，而该对象的 `x` 属性被设置为了对新对象 `{n: 2}` 的引用

这个示例很好地展示了：
1. 赋值运算符是从右到左结合的
2. 对象属性访问时，对象引用是在赋值前就确定的
3. 引用类型变量的赋值实际上是改变引用指向，而不是修改原对象

## 总结

赋值运算符虽然看起来简单，但其内部执行过程涉及变量查找、表达式计算、内存操作等多个步骤。理解这些步骤有助于我们：

- 更好地理解 JavaScript 的内存管理机制
- 避免一些常见的赋值错误
- 编写出更高效的代码
