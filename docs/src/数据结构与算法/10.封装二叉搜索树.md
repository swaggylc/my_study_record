---
date: 2025-09-21 21:06:05
title: 封装二叉搜索树
permalink: /pages/c8603d
categories:
  - src
  - 数据结构与算法
---
# 二叉搜索树（BST）封装实现

二叉搜索树（Binary Search Tree，BST）是一种特殊的二叉树，它具有以下特性：
- 左子树上的所有节点值均小于其根节点值
- 右子树上的所有节点值均大于其根节点值
- 左右子树也分别是二叉搜索树

这种结构使得二叉搜索树的查找、插入和删除操作可以在平均情况下达到 O(log n) 的时间复杂度，非常适合用于高效的数据检索。

## 1. 基本概念与原理

### 1.1 递归思想
在二叉搜索树的实现中，递归是一种非常重要的思想，其核心步骤包括：
1. 确定递归函数的参数和返回值
2. 确定递归终止条件（递归出口），无递归出口会导致栈溢出
3. 确定单层递归的逻辑

### 1.2 函数执行栈
二叉搜索树的递归操作依赖于 JavaScript 的函数执行栈，每次递归调用都会创建一个新的函数执行上下文并压入栈中，完成后再弹出栈。

## 2. 二叉搜索树的封装实现

下面是一个完整的二叉搜索树 JavaScript 封装实现：

```javascript
// 封装二叉搜索树
function BinarySearchTree() {
    // 节点类
    function Node(key) {
        this.key = key; // 节点值
        this.left = null; // 左子节点
        this.right = null; // 右子节点
    }

    // 属性
    this.root = null; // 根节点

    // 方法
    // insert(key) 插入新的节点
    BinarySearchTree.prototype.insert = function(key) {
        // 新建节点
        let node = new Node(key);
        // 判断是否有根节点
        if (this.root == null) {
            this.root = node;
            return true;
        } else {
            // 使用递归方法插入节点
            this.insertNode(this.root, node);
        }
    }
    
    // insertNode 递归插入节点
    BinarySearchTree.prototype.insertNode = function(node, newNode) {
        if (node.key > newNode.key) {
            // 向左查找
            if (node.left == null) {
                node.left = newNode;
            } else {
                this.insertNode(node.left, newNode);
            }
        } else {
            // 向右查找
            if (node.right == null) {
                node.right = newNode;
            } else {
                this.insertNode(node.right, newNode);
            }
        }
    }

    // search(key) 查找节点
    BinarySearchTree.prototype.search = function(key) {
        if (this.root == null) return false;
        let current = this.root;
        while (current) {
            if (current.key == key) {
                return true;
            } else if (current.key < key) {
                current = current.right;
            } else {
                current = current.left;
            }
        }
        return false;
    }

    // preOrderTraverse 先序遍历 (根-左-右)
    BinarySearchTree.prototype.preOrderTraverse = function() {
        if (this.root == null) return null;
        this.preOrderTraverseNode(this.root);
    }
    
    BinarySearchTree.prototype.preOrderTraverseNode = function(node) {
        if (node != null) {
            // 处理当前节点
            console.log(node.key);
            // 递归处理左子树
            this.preOrderTraverseNode(node.left);
            // 递归处理右子树
            this.preOrderTraverseNode(node.right);
        }
    }

    // inOrderTraverse 中序遍历 (左-根-右)
    // 中序遍历二叉搜索树会得到一个有序序列
    BinarySearchTree.prototype.inOrderTraverse = function() {
        if (this.root == null) return null;
        this.inOrderTraverseNode(this.root);
    }
    
    BinarySearchTree.prototype.inOrderTraverseNode = function(node) {
        if (node != null) {
            // 递归处理左子树
            this.inOrderTraverseNode(node.left);
            // 处理当前节点
            console.log(node.key);
            // 递归处理右子树
            this.inOrderTraverseNode(node.right);
        }
    }

    // postOrderTraverse 后序遍历 (左-右-根)
    BinarySearchTree.prototype.postOrderTraverse = function() {
        if (this.root == null) return null;
        this.postOrderTraverseNode(this.root);
    }
    
    BinarySearchTree.prototype.postOrderTraverseNode = function(node) {
        if (node != null) {
            // 递归处理左子树
            this.postOrderTraverseNode(node.left);
            // 递归处理右子树
            this.postOrderTraverseNode(node.right);
            // 处理当前节点
            console.log(node.key);
        }
    }

    // min 查找树中的最小值
    BinarySearchTree.prototype.min = function() {
        if (this.root == null) return null;
        let current = this.root;
        while (current.left != null) {
            current = current.left;
        }
        return current.key;
    }

    // max 查找树中的最大值
    BinarySearchTree.prototype.max = function() {
        if (this.root == null) return null;
        let current = this.root;
        while (current.right != null) {
            current = current.right;
        }
        return current.key;
    }

    // remove(key) 移除某个节点
    BinarySearchTree.prototype.remove = function(key) {
        if (this.root == null) return false;
        let current = this.root;
        let parent = null;
        let isLeftChild = true;
        
        // 1. 查找要删除的节点
        while (current.key != key) {
            parent = current;
            if (current.key > key) {
                isLeftChild = true;
                current = current.left;
            } else {
                isLeftChild = false;
                current = current.right;
            }
            if (current == null) return false; // 未找到节点
        }
        
        // 2. 根据节点类型执行删除操作
        
        // 情况1: 删除叶子节点（没有子节点）
        if (current.left == null && current.right == null) {
            if (current == this.root) {
                this.root = null;
            } else if (isLeftChild) {
                parent.left = null;
            } else {
                parent.right = null;
            }
        }
        
        // 情况2: 删除有一个子节点的节点
        else if (current.right == null) {
            // 只有左子节点
            if (current == this.root) {
                this.root = current.left;
            } else if (isLeftChild) {
                parent.left = current.left;
            } else {
                parent.right = current.left;
            }
        } else if (current.left == null) {
            // 只有右子节点
            if (current == this.root) {
                this.root = current.right;
            } else if (isLeftChild) {
                parent.left = current.right;
            } else {
                parent.right = current.right;
            }
        }
        
        // 情况3: 删除有两个子节点的节点
        // 策略：找到待删除节点的后继节点（右子树中的最小值）
        else {
            let successorNode = this.getSuccessor(current);
            
            // 连接后继节点到父节点
            if (current == this.root) {
                this.root = successorNode;
            } else if (isLeftChild) {
                parent.left = successorNode;
            } else {
                parent.right = successorNode;
            }
            
            // 连接后继节点到当前节点的左子树
            successorNode.left = current.left;
        }
        
        return true;
    }
    
    // getSuccessor 寻找后继节点（用于删除有两个子节点的节点）
    BinarySearchTree.prototype.getSuccessor = function(delNode) {
        let current = delNode.right;
        let successorNode = delNode;
        let successorParent = delNode;
        
        // 查找右子树中的最小值
        while (current) {
            successorParent = successorNode;
            successorNode = current;
            current = current.left;
        }
        
        // 如果后继节点不是删除节点的直接右节点
        if (successorNode != delNode.right) {
            successorParent.left = successorNode.right;
            successorNode.right = delNode.right;
        }
        
        return successorNode;
    }
}
```

## 3. 方法详解

### 3.1 插入操作 (insert)
插入操作通过递归方式实现，根据二叉搜索树的特性，小于当前节点的值放在左侧，大于等于当前节点的值放在右侧。

**时间复杂度**：平均 O(log n)，最坏 O(n)（当树退化为链表时）

### 3.2 查找操作 (search)
查找操作通过迭代方式实现，根据目标值与当前节点值的比较结果决定向左还是向右子树查找。

**时间复杂度**：平均 O(log n)，最坏 O(n)

### 3.3 遍历操作
二叉搜索树支持三种常见的遍历方式：

1. **先序遍历 (preOrderTraverse)**：根 -> 左 -> 右
2. **中序遍历 (inOrderTraverse)**：左 -> 根 -> 右
   *特别说明*：中序遍历二叉搜索树会产生一个有序序列
3. **后序遍历 (postOrderTraverse)**：左 -> 右 -> 根

**时间复杂度**：O(n)，其中 n 是树中的节点数

### 3.4 最值查找
- **最小值查找 (min)**：从根节点开始，一直向左遍历，直到找到没有左子节点的节点
- **最大值查找 (max)**：从根节点开始，一直向右遍历，直到找到没有右子节点的节点

**时间复杂度**：平均 O(log n)，最坏 O(n)

### 3.5 删除操作 (remove)
删除操作是二叉搜索树中最复杂的操作，需要处理三种不同情况：
1. 删除叶子节点（无子女）：直接删除
2. 删除有一个子节点的节点：用子节点替换当前节点
3. 删除有两个子节点的节点：用后继节点（右子树中的最小值）替换当前节点

**时间复杂度**：平均 O(log n)，最坏 O(n)

## 4. 测试示例

下面是一个完整的测试示例，展示如何使用上面实现的二叉搜索树：

```javascript
// 创建二叉搜索树实例
let binaryST = new BinarySearchTree();

// 插入节点
binaryST.insert(9);
binaryST.insert(6);
binaryST.insert(13);
binaryST.insert(5);
binaryST.insert(8);
binaryST.insert(10);
binaryST.insert(17);
binaryST.insert(15);
binaryST.insert(20);
binaryST.insert(16);

// 中序遍历（应输出有序序列）
console.log("中序遍历结果：");
binaryST.inOrderTraverse();
console.log('-------------');

// 查找最小值
console.log('最小值--', binaryST.min());
console.log('-------------');

// 查找最大值
console.log('最大值--', binaryST.max());
console.log('-------------');

// 搜索节点
console.log('搜索节点--10', binaryST.search(10)); // 应返回 true
console.log('搜索节点--23', binaryST.search(23)); // 应返回 false
console.log('搜索节点--5', binaryST.search(5));   // 应返回 true
console.log('搜索节点--9', binaryST.search(9));   // 应返回 true
console.log('-------------');

// 删除节点
console.log("删除节点 13 结果：", binaryST.remove(13));
console.log('-------------');

// 删除节点后的中序遍历
console.log("删除节点后的中序遍历：");
binaryST.inOrderTraverse();
```

## 5. 执行结果

执行上面的测试代码，应该会得到以下输出：

```
中序遍历结果：
5
6
8
9
10
13
15
16
17
20
-------------
最小值-- 5
-------------
最大值-- 20
-------------
搜索节点--10 true
搜索节点--23 false
搜索节点--5 true
搜索节点--9 true
-------------
删除节点 13 结果： true
-------------
删除节点后的中序遍历：
5
6
8
9
10
15
16
17
20
```

## 6. 应用场景

二叉搜索树在计算机科学中有广泛的应用，主要包括：

1. **数据库索引**：许多数据库系统使用二叉搜索树或其变种（如B树、B+树）来加速数据查询
2. **符号表实现**：在编译器和解释器中用于实现符号表
3. **优先队列**：通过二叉堆（一种特殊的二叉树）实现
4. **排序算法**：二叉搜索树排序是一种高效的排序算法
5. **文件系统**：用于组织和检索文件系统中的文件

## 7. 优缺点分析

### 优点：
- 查找、插入和删除操作平均时间复杂度为 O(log n)
- 中序遍历可以得到有序数据
- 结构简单，易于实现

### 缺点：
- 在最坏情况下（树退化为链表），操作时间复杂度会降为 O(n)
- 频繁的插入和删除操作可能导致树失衡
- 不适合存储重复元素（除非特别处理）

为了克服这些缺点，可以使用平衡二叉搜索树，如AVL树、红黑树等，它们能够在插入和删除操作中保持树的平衡性，确保操作的时间复杂度始终保持在 O(log n) 级别。
