---
date: "2025-09-20T17:25:41+08:00"
---
# 双向链表的封装

双向链表是链表的一种扩展形式，它的每个节点不仅包含指向下一个节点的引用，还包含指向前一个节点的引用。这种结构使得在双向链表中可以从头到尾或从尾到头进行遍历，同时在插入和删除操作时也更加灵活。本文将介绍如何在JavaScript中实现一个双向链表。

## 双向链表的基本实现

以下是双向链表的基本实现代码：

```javascript
// 封装双向链表
function DoubleLinkedList() {
    // 属性
    this.head = null;  // 头节点
    this.tail = null;  // 尾节点
    this.length = 0;   // 链表长度

    // 节点类
    function Node(data) {
        this.previous = null;  // 指向前一个节点
        this.next = null;      // 指向后一个节点
        this.data = data;      // 节点数据
    }

    // 方法
    // append方法 - 向链表尾部添加元素
    DoubleLinkedList.prototype.append = function (data) {
        // 新建节点
        let node = new Node(data);
        // 判断链表是否为空
        if (this.length == 0) {
            this.head = node;
            this.tail = node;
        } else {
            // 链表不为空
            let current = this.head;
            while (current.next) {
                current = current.next;
            }
            current.next = node;
            node.previous = current;
            this.tail = node;
        }
        this.length += 1;
        return this.length;
    };

    // toString方法 - 从前往后遍历
    DoubleLinkedList.prototype.toString = function () {
        let current = this.head;
        let resString = '';
        while (current) {
            resString += current.data + ' ';
            current = current.next;
        }
        return resString;
    };

    // forwordString方法 - 从后往前遍历
    DoubleLinkedList.prototype.forwordString = function () {
        let current = this.tail;
        let resString = '';
        while (current) {
            resString += current.data + ' ';
            current = current.previous;
        }
        return resString;
    };

    // backwordString方法 - 从前往后遍历（同toString）
    DoubleLinkedList.prototype.backwordString = function () {
        return this.toString();
    };

    // insert方法 - 在指定位置插入元素
    DoubleLinkedList.prototype.insert = function (data, position) {
        // 新建节点
        let node = new Node(data);
        // 判断是否越界
        if (position < 0 || position > this.length) {
            return false;
        }
        let current = this.head;
        let index = 0;
        // 判断链表是否为空
        if (this.length == 0) {
            this.head = node;
            this.tail = node;
        } else {
            // 判断插入的位置
            if (position == 0) {
                this.head = node;
                node.next = current;
                current.previous = node;
            } else if (position == this.length) {
                this.tail.next = node;
                node.previous = this.tail;
                this.tail = node;
            } else {
                while (index++ < position) {
                    current = current.next;
                }
                current.previous.next = node;
                node.previous = current.previous;
                current.previous = node;
                node.next = current;
            }
        }
        this.length += 1;
        return true;
    };

    // get方法 - 获取指定位置的元素
    DoubleLinkedList.prototype.get = function (position) {
        // 判断是否越界
        if (position < 0 || position >= this.length) return null;
        let current = this.head;
        let index = 0;
        while (index++ < position) {
            current = current.next;
        }
        return current.data;
    };

    // indexOf方法 - 查找元素的位置
    DoubleLinkedList.prototype.indexOf = function (data) {
        let current = this.head;
        let index = 0;
        while (current) {
            if (current.data === data) {
                return index;
            }
            current = current.next;
            index += 1;
        }
        return -1;
    };

    // update方法 - 更新指定位置的元素
    DoubleLinkedList.prototype.update = function (data, position) {
        // 判断是否越界
        if (position < 0 || position >= this.length) return false;
        let current = this.head;
        let index = 0;
        while (index++ < position) {
            current = current.next;
        }
        current.data = data;
        return true;
    };

    // removeAt方法 - 移除指定位置的元素
    DoubleLinkedList.prototype.removeAt = function (position) {
        // 判断越界
        if (position < 0 || position >= this.length) return false;
        let current = this.head;
        let index = 0;
        // 若链表只有一个节点
        if (this.length == 1) {
            this.head = null;
            this.tail = null;
        } else {
            if (position == 0) {
                // 若删除的位置为0
                this.head = current.next;
                this.head.previous = null;
            } else if (position == this.length - 1) {
                // 若删除的是最后一个
                current = this.tail;
                this.tail = current.previous;
                this.tail.next = null;
            } else {
                while (index++ < position) {
                    current = current.next;
                }
                current.previous.next = current.next;
                current.next.previous = current.previous;
                current.previous = null;
                current.next = null;
            }
        }
        this.length -= 1;
        return current.data;
    };

    // remove方法 - 移除指定元素
    DoubleLinkedList.prototype.remove = function (data) {
        // 使用indexOf方法获取index，再使用removeAt方法移除
        return this.removeAt(this.indexOf(data));
    };

    // isEmpty方法 - 判断链表是否为空
    DoubleLinkedList.prototype.isEmpty = function () {
        return this.length == 0;
    };

    // size方法 - 获取链表长度
    DoubleLinkedList.prototype.size = function () {
        return this.length;
    };

    // 返回链表的第一个节点
    DoubleLinkedList.prototype.getHead = function () {
        return this.head ? this.head.data : null;
    };

    // 返回链表的最后一个节点
    DoubleLinkedList.prototype.getTail = function () {
        return this.tail ? this.tail.data : null;
    };
}
```

## 双向链表的使用示例

以下是双向链表的基本使用示例：

```javascript
// 创建双向链表实例
let doubleLL = new DoubleLinkedList();

// 测试append方法
console.log('添加元素1:', doubleLL.append(1));  // 输出: 1
console.log('添加元素10:', doubleLL.append(10));  // 输出: 2
console.log('添加元素110:', doubleLL.append(110));  // 输出: 3
console.log('添加元素119:', doubleLL.append(119));  // 输出: 4

// 测试toString方法（从前往后遍历）
console.log('从前往后遍历:', doubleLL.toString());  // 输出: 1 10 110 119 

// 测试forwordString方法（从后往前遍历）
console.log('从后往前遍历:', doubleLL.forwordString());  // 输出: 119 110 10 1 

// 测试insert方法
console.log('在位置2插入元素50:', doubleLL.insert(50, 2));  // 输出: true
console.log('插入后的链表:', doubleLL.toString());  // 输出: 1 10 50 110 119 

// 测试在头部插入
console.log('在位置0插入元素100:', doubleLL.insert(100, 0));  // 输出: true
console.log('头部插入后的链表:', doubleLL.toString());  // 输出: 100 1 10 50 110 119 

// 测试在尾部插入
console.log('在尾部插入元素200:', doubleLL.insert(200, doubleLL.size()));  // 输出: true
console.log('尾部插入后的链表:', doubleLL.toString());  // 输出: 100 1 10 50 110 119 200 

// 测试get方法
console.log('获取位置3的元素:', doubleLL.get(3));  // 输出: 50

// 测试indexOf方法
console.log('元素110的索引:', doubleLL.indexOf(110));  // 输出: 4

// 测试update方法
console.log('更新位置1的元素为2:', doubleLL.update(2, 1));  // 输出: true
console.log('更新后的链表:', doubleLL.toString());  // 输出: 100 2 10 50 110 119 200 

// 测试removeAt方法
console.log('移除位置2的元素:', doubleLL.removeAt(2));  // 输出: 10
console.log('移除后的链表:', doubleLL.toString());  // 输出: 100 2 50 110 119 200 

// 测试remove方法
console.log('移除元素119:', doubleLL.remove(119));  // 输出: 119
console.log('移除后的链表:', doubleLL.toString());  // 输出: 100 2 50 110 200 

// 测试getHead和getTail方法
console.log('链表头部元素:', doubleLL.getHead());  // 输出: 100
console.log('链表尾部元素:', doubleLL.getTail());  // 输出: 200

// 测试isEmpty和size方法
console.log('链表是否为空:', doubleLL.isEmpty());  // 输出: false
console.log('链表长度:', doubleLL.size());  // 输出: 5
```

## 更多测试用例

让我们增加一些额外的测试用例来验证双向链表的各种边界情况：

```javascript
// 测试边界情况
let emptyDoubleLL = new DoubleLinkedList();
console.log('\n空双向链表测试:');
console.log('isEmpty:', emptyDoubleLL.isEmpty());  // true
console.log('size:', emptyDoubleLL.size());  // 0
console.log('get(0):', emptyDoubleLL.get(0));  // null
console.log('getHead():', emptyDoubleLL.getHead());  // null
console.log('getTail():', emptyDoubleLL.getTail());  // null

// 测试单元素链表
emptyDoubleLL.append('single');
console.log('\n单元素链表测试:');
console.log('从前往后遍历:', emptyDoubleLL.toString());  // single 
console.log('从后往前遍历:', emptyDoubleLL.forwordString());  // single 
console.log('getHead():', emptyDoubleLL.getHead());  // single
console.log('getTail():', emptyDoubleLL.getTail());  // single

// 测试移除唯一元素
console.log('移除唯一元素:', emptyDoubleLL.removeAt(0));  // single
console.log('移除后的链表是否为空:', emptyDoubleLL.isEmpty());  // true

// 测试不存在的元素操作
console.log('\n操作不存在的元素:');
console.log('查找不存在元素的索引:', doubleLL.indexOf('notExist'));  // -1
console.log('移除不存在的元素:', doubleLL.remove('notExist'));  // false
console.log('越界操作:', doubleLL.get(100));  // null
console.log('越界更新:', doubleLL.update(999, 100));  // false
console.log('越界插入:', doubleLL.insert(888, 100));  // false
```

## 算法原理解析

### 双向链表的核心概念

双向链表与单链表的主要区别在于，每个节点不仅有指向下一个节点的引用（`next`），还有指向前一个节点的引用（`previous`）。这种结构使得双向链表具有以下特点：

1. **双向遍历**：可以从头节点开始往后遍历，也可以从尾节点开始往前遍历
2. **方便的插入和删除**：在已知节点位置的情况下，插入和删除操作不需要遍历链表找到前驱节点
3. **额外的空间开销**：每个节点需要额外的空间存储`previous`引用

### 各方法的实现原理

1. **append(data)**：向链表尾部添加元素
   - 创建新节点
   - 如果链表为空，新节点既是头节点也是尾节点
   - 否则，将最后一个节点的`next`指向新节点，将新节点的`previous`指向前一个节点
   - 更新尾节点为新节点
   - 时间复杂度：O(n)，需要遍历找到链表尾部

2. **insert(data, position)**：在指定位置插入元素
   - 边界检查
   - 创建新节点
   - 根据插入位置的不同，分为三种情况：
     - 插入到头部（位置0）
     - 插入到尾部（位置length）
     - 插入到中间位置
   - 调整相应的`next`和`previous`引用
   - 更新链表长度
   - 时间复杂度：O(n)，最坏情况下需要遍历到指定位置

3. **removeAt(position)**：移除指定位置的元素
   - 边界检查
   - 根据移除位置的不同，分为三种情况：
     - 移除头部元素（位置0）
     - 移除尾部元素（位置length-1）
     - 移除中间元素
   - 调整相应的`next`和`previous`引用，跳过要移除的节点
   - 更新链表长度
   - 时间复杂度：O(n)，最坏情况下需要遍历到指定位置

4. **get(position)、indexOf(data)、update(data, position)** 等方法与单链表类似，但在某些操作上可能可以利用双向链表的特性进行优化

## 性能分析

- **空间复杂度**：O(n)，每个节点需要额外的空间存储`previous`引用
- **时间复杂度**：
  - 访问/查找元素：O(n)
  - 插入元素：O(n)（需要先找到插入位置），但在已知节点位置的情况下为O(1)
  - 删除元素：O(n)（需要先找到删除位置），但在已知节点位置的情况下为O(1)
  - 在链表头部/尾部插入/删除：O(1)

相比于单链表，双向链表的优势在于可以双向遍历，并且在已知节点位置的情况下插入和删除操作更加高效，但代价是每个节点需要额外的存储空间来存储前驱节点的引用。

## ES6版本实现

下面是使用ES6语法实现的双向链表：

```javascript
class DoubleLinkedListES6 {
    constructor() {
        this.head = null;
        this.tail = null;
        this.length = 0;
    }

    // 节点类
    Node = class {
        constructor(data) {
            this.previous = null;
            this.next = null;
            this.data = data;
        }
    }

    // 向链表尾部添加元素
    append(data) {
        const node = new this.Node(data);
        
        if (this.length === 0) {
            this.head = node;
            this.tail = node;
        } else {
            this.tail.next = node;
            node.previous = this.tail;
            this.tail = node;
        }
        
        this.length++;
        return this.length;
    }

    // 从前往后遍历
    toString() {
        let current = this.head;
        let result = '';
        
        while (current) {
            result += current.data + ' ';
            current = current.next;
        }
        
        return result.trim();
    }

    // 从后往前遍历
    forwordString() {
        let current = this.tail;
        let result = '';
        
        while (current) {
            result += current.data + ' ';
            current = current.previous;
        }
        
        return result.trim();
    }

    // 从前往后遍历（同toString）
    backwordString() {
        return this.toString();
    }

    // 在指定位置插入元素
    insert(data, position) {
        // 边界检查
        if (position < 0 || position > this.length) {
            return false;
        }
        
        const node = new this.Node(data);
        
        // 空链表情况
        if (this.length === 0) {
            this.head = node;
            this.tail = node;
        } else if (position === 0) {
            // 头部插入
            node.next = this.head;
            this.head.previous = node;
            this.head = node;
        } else if (position === this.length) {
            // 尾部插入
            this.tail.next = node;
            node.previous = this.tail;
            this.tail = node;
        } else {
            // 中间插入
            let current = this.head;
            let index = 0;
            
            while (index++ < position) {
                current = current.next;
            }
            
            node.next = current;
            node.previous = current.previous;
            current.previous.next = node;
            current.previous = node;
        }
        
        this.length++;
        return true;
    }

    // 获取指定位置的元素
    get(position) {
        if (position < 0 || position >= this.length) return null;
        
        let current = this.head;
        let index = 0;
        
        while (index++ < position) {
            current = current.next;
        }
        
        return current.data;
    }

    // 查找元素的位置
    indexOf(data) {
        let current = this.head;
        let index = 0;
        
        while (current) {
            if (current.data === data) {
                return index;
            }
            current = current.next;
            index++;
        }
        
        return -1;
    }

    // 更新指定位置的元素
    update(data, position) {
        if (position < 0 || position >= this.length) return false;
        
        let current = this.head;
        let index = 0;
        
        while (index++ < position) {
            current = current.next;
        }
        
        current.data = data;
        return true;
    }

    // 移除指定位置的元素
    removeAt(position) {
        if (position < 0 || position >= this.length) return false;
        
        let current = this.head;
        
        // 单节点链表
        if (this.length === 1) {
            this.head = null;
            this.tail = null;
        } else if (position === 0) {
            // 移除头部
            this.head = current.next;
            this.head.previous = null;
        } else if (position === this.length - 1) {
            // 移除尾部
            current = this.tail;
            this.tail = current.previous;
            this.tail.next = null;
        } else {
            // 移除中间
            let index = 0;
            while (index++ < position) {
                current = current.next;
            }
            
            current.previous.next = current.next;
            current.next.previous = current.previous;
        }
        
        this.length--;
        return current.data;
    }

    // 移除指定元素
    remove(data) {
        const index = this.indexOf(data);
        return this.removeAt(index);
    }

    // 判断链表是否为空
    isEmpty() {
        return this.length === 0;
    }

    // 获取链表长度
    size() {
        return this.length;
    }

    // 获取头部元素
    getHead() {
        return this.head ? this.head.data : null;
    }

    // 获取尾部元素
    getTail() {
        return this.tail ? this.tail.data : null;
    }
}
```