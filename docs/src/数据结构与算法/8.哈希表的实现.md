---
date: 2025-09-20 20:10:24
title: 哈希表的实现
permalink: /pages/0b34bb
categories:
  - src
  - 数据结构与算法
---


# 哈希表的实现

哈希表是一种非常重要的数据结构，它能够以O(1)的平均时间复杂度进行查找、插入和删除操作。哈希表通过哈希函数将键映射到表中的某个位置，从而实现高效的数据存取。在本文中，我们将学习如何在JavaScript中实现一个完整的哈希表。

## 哈希表的基本实现

下面是哈希表的基本实现代码：

```javascript
/**
 * 哈希表类的实现
 * 使用链地址法解决哈希冲突
 */
function HashTable() {
    // 属性
    this.storage = [];     // 存储数据的数组
    this.count = 0;        // 元素个数
    this.limit = 7;        // 数组初始长度（质数）
    
    // 方法
    // 哈希函数
    HashTable.prototype.hashFn = function (str, size) {
        // 定义hashcode变量
        let hashcode = 0;
        // 根据霍纳法则计算哈希值
        for (let i = 0; i < str.length; i++) {
            hashcode = 37 * hashcode + str.charCodeAt(i);
        }
        // 将hashcode压缩到指定大小范围内
        let index = hashcode % size;
        return index;
    };
    
    // 插入/修改操作
    HashTable.prototype.put = function (key, value) {
        // 根据key获取对应的索引
        let index = this.hashFn(key, this.limit);
        // 根据索引值取出bucket
        let bucket = this.storage[index];
        // 判断bucket是否为空
        if (bucket == null) {
            bucket = [];
            this.storage[index] = bucket;
        }
        // 判断是新增还是修改
        for (let i = 0; i < bucket.length; i++) {
            let arr = bucket[i];
            if (arr[0] === key) {
                arr[1] = value;  // 修改现有值
                return;
            }
        }
        // 新增键值对
        bucket.push([key, value]);
        // 元素计数加一
        this.count += 1;
        // 判断是否需要扩容
        if (this.count > this.limit * 0.75) {
            // 扩容到原来的两倍左右，并确保是质数
            this.limit = this.limit * 2;
            while (!this.isPrime(this.limit)) {
                this.limit += 1;
            }
            this.resize(this.limit);
        }
    };
    
    // 获取操作
    HashTable.prototype.get = function (key) {
        // 根据key获取对应的索引
        let index = this.hashFn(key, this.limit);
        // 根据索引值取出bucket
        let bucket = this.storage[index];
        // 判断bucket是否为空
        if (bucket == null) {
            return null;
        }
        // 遍历bucket，查找对应的key
        for (let i = 0; i < bucket.length; i++) {
            let arr = bucket[i];
            if (arr[0] === key) {
                return arr[1];  // 返回值
            }
        }
        return null;  // 未找到对应key
    };
    
    // 删除方法
    HashTable.prototype.remove = function (key) {
        // 根据key获取对应的索引
        let index = this.hashFn(key, this.limit);
        // 根据索引值取出bucket
        let bucket = this.storage[index];
        // 判断bucket是否为空
        if (bucket == null) {
            return null;
        }
        // 遍历bucket，查找并删除对应的key
        for (let i = 0; i < bucket.length; i++) {
            let arr = bucket[i];
            if (arr[0] === key) {
                bucket.splice(i, 1);  // 从bucket中删除
                this.count -= 1;      // 元素计数减一
                // 判断是否需要缩容
                if (this.limit > 7 && this.count < this.limit * 0.25) {
                    // 缩容到原来的一半左右，并确保是质数
                    this.limit = Math.floor(this.limit / 2);
                    while (!this.isPrime(this.limit)) {
                        this.limit += 1;
                    }
                    this.resize(this.limit);
                }
                return arr[1];  // 返回被删除的值
            }
        }
        return null;  // 未找到要删除的key
    };
    
    // 判断哈希表是否为空
    HashTable.prototype.isEmpty = function () {
        return this.count === 0;
    };
    
    // 获取哈希表元素个数
    HashTable.prototype.size = function () {
        return this.count;
    };

    // 哈希表扩容/缩容
    HashTable.prototype.resize = function (newLimit) {
        // 保存旧的存储数组
        let oldStorage = this.storage;
        // 重置属性
        this.storage = [];
        this.limit = newLimit;
        this.count = 0;
        // 遍历旧数组，将元素重新插入到新数组
        for (let i = 0; i < oldStorage.length; i++) {
            if (oldStorage[i] == null) {
                continue;
            }
            // 取出bucket
            let bucket = oldStorage[i];
            // 遍历bucket
            for (let j = 0; j < bucket.length; j++) {
                let arr = bucket[j];
                // 将元素重新put到新数组
                this.put(arr[0], arr[1]);
            }
        }
    };
    
    // 判断质数方法
    HashTable.prototype.isPrime = function (number) {
        // 排除特殊情况
        if (number <= 1) return false;
        if (number === 2) return true;
        if (number % 2 === 0) return false;
        
        // 只需检查到平方根即可
        let temp = Math.floor(Math.sqrt(number));
        for (let i = 3; i <= temp; i += 2) {
            if (number % i === 0) {
                return false;
            }
        }
        return true;
    };
}
```

## 哈希表的使用示例

下面是哈希表的基本使用示例：

```javascript
// 创建哈希表实例
let hashtable = new HashTable();

// 插入数据
hashtable.put('张三', {
    name: '张三',
    age: 18,
    address: '北京'
});

hashtable.put('李四', {
    name: '李四',
    age: 28,
    address: '上海'
});

hashtable.put('王五', {
    name: '王五',
    age: 45,
    address: '天津'
});

// 获取数据
console.log(hashtable.get('张三'));  // 输出: {name: '张三', age: 18, address: '北京'}
console.log(hashtable.get('李四'));  // 输出: {name: '李四', age: 28, address: '上海'}
console.log(hashtable.get('王五'));  // 输出: {name: '王五', age: 45, address: '天津'}
console.log(hashtable.get('aaa'));   // 输出: null (不存在的键)

// 修改数据
hashtable.put('王五', {
    name: '王五',
    age: 45,
    address: '江西'
});
console.log(hashtable.get('王五'));  // 输出: {name: '王五', age: 45, address: '江西'}

// 删除数据
hashtable.remove('张三');
console.log(hashtable.get('张三'));  // 输出: null (已删除)

// 获取哈希表状态
console.log(hashtable.isEmpty());    // 输出: false
console.log(hashtable.size());       // 输出: 2
```

## 哈希表的原理分析

### 1. 哈希冲突解决

本实现使用了**链地址法**（Separate Chaining）来解决哈希冲突：
- 当多个键映射到哈希表的同一个位置时，将它们存储在同一个桶（bucket）中
- 每个桶实际上是一个数组，用于存储发生哈希冲突的键值对
- 查找时，先通过哈希函数定位到桶，然后在桶内顺序查找

### 2. 动态扩容与缩容

为了保持哈希表的性能，实现了动态扩容与缩容机制：
- 当元素数量超过数组长度的75%时，进行扩容（扩容到原来的两倍左右，并确保是质数）
- 当元素数量少于数组长度的25%且数组长度大于初始值7时，进行缩容（缩容到原来的一半左右，并确保是质数）
- 扩容和缩容时，需要重新计算所有元素的哈希值并重新插入

### 3. 为什么使用质数作为数组长度？

选择质数作为哈希表的数组长度有以下好处：
1. **减少哈希冲突**：质数的因数较少，能使哈希值分布更均匀
2. **降低冲突聚集**：避免某些特定模式的键导致冲突集中在某些位置
3. **提高查询效率**：均匀分布的哈希值可以减少在桶内的查找时间

### 4. 代码优化点

在原有实现中，resize方法存在一个bug：在遍历bucket时，变量名使用了与外部循环相同的`i`，这会导致变量覆盖。修复后的代码使用了`j`作为内部循环变量名。

## 更完善的测试用例

下面是更全面的测试用例，用于验证哈希表的各种功能和边界情况：

```javascript
// 测试哈希表的基本功能
function testHashTable() {
    const ht = new HashTable();
    
    // 测试插入和获取
    console.log('===== 测试插入和获取 =====');
    ht.put('key1', 'value1');
    ht.put('key2', 'value2');
    ht.put('key3', 'value3');
    console.log(ht.get('key1'));  // 应输出: value1
    console.log(ht.get('key2'));  // 应输出: value2
    console.log(ht.get('key3'));  // 应输出: value3
    console.log(ht.get('key4'));  // 应输出: null
    
    // 测试更新
    console.log('\n===== 测试更新 =====');
    ht.put('key1', 'new_value1');
    console.log(ht.get('key1'));  // 应输出: new_value1
    
    // 测试删除
    console.log('\n===== 测试删除 =====');
    console.log(ht.remove('key2'));  // 应输出: value2
    console.log(ht.get('key2'));     // 应输出: null
    
    // 测试大小和空判断
    console.log('\n===== 测试大小和空判断 =====');
    console.log(ht.size());      // 应输出: 2
    console.log(ht.isEmpty());   // 应输出: false
    
    // 测试扩容
    console.log('\n===== 测试扩容 =====');
    const initialLimit = ht.limit;
    for (let i = 0; i < 10; i++) {
        ht.put(`expand_key${i}`, `expand_value${i}`);
    }
    console.log(`初始数组长度: ${initialLimit}, 扩容后数组长度: ${ht.limit}`);
    
    // 测试缩容
    console.log('\n===== 测试缩容 =====');
    const expandedLimit = ht.limit;
    for (let i = 0; i < 10; i++) {
        ht.remove(`expand_key${i}`);
    }
    console.log(`扩容后数组长度: ${expandedLimit}, 缩容后数组长度: ${ht.limit}`);
    
    // 测试清空
    console.log('\n===== 测试清空 =====');
    ht.remove('key1');
    ht.remove('key3');
    console.log(ht.isEmpty());  // 应输出: true
    console.log(ht.size());     // 应输出: 0
}

testHashTable();
```

## ES6版本实现

下面是哈希表的ES6版本实现，使用了类和现代JavaScript特性：

```javascript
/**
 * ES6版本的哈希表实现
 */
class HashTableES6 {
    constructor() {
        this.storage = [];     // 存储数据的数组
        this.count = 0;        // 元素个数
        this.limit = 7;        // 数组初始长度（质数）
    }
    
    // 哈希函数
    hashFn(str, size) {
        let hashcode = 0;
        for (let i = 0; i < str.length; i++) {
            hashcode = 37 * hashcode + str.charCodeAt(i);
        }
        return hashcode % size;
    }
    
    // 判断是否为质数
    isPrime(number) {
        if (number <= 1) return false;
        if (number === 2) return true;
        if (number % 2 === 0) return false;
        
        const temp = Math.floor(Math.sqrt(number));
        for (let i = 3; i <= temp; i += 2) {
            if (number % i === 0) {
                return false;
            }
        }
        return true;
    }
    
    // 插入/修改操作
    put(key, value) {
        const index = this.hashFn(key, this.limit);
        let bucket = this.storage[index];
        
        if (!bucket) {
            bucket = [];
            this.storage[index] = bucket;
        }
        
        // 检查是否更新已有键
        for (let i = 0; i < bucket.length; i++) {
            const [k, v] = bucket[i];
            if (k === key) {
                bucket[i] = [key, value];
                return;
            }
        }
        
        // 新增键值对
        bucket.push([key, value]);
        this.count++;
        
        // 检查是否需要扩容
        if (this.count > this.limit * 0.75) {
            this.limit *= 2;
            while (!this.isPrime(this.limit)) {
                this.limit++;
            }
            this.resize(this.limit);
        }
    }
    
    // 获取操作
    get(key) {
        const index = this.hashFn(key, this.limit);
        const bucket = this.storage[index];
        
        if (!bucket) {
            return null;
        }
        
        for (const [k, v] of bucket) {
            if (k === key) {
                return v;
            }
        }
        
        return null;
    }
    
    // 删除操作
    remove(key) {
        const index = this.hashFn(key, this.limit);
        const bucket = this.storage[index];
        
        if (!bucket) {
            return null;
        }
        
        for (let i = 0; i < bucket.length; i++) {
            const [k, v] = bucket[i];
            if (k === key) {
                bucket.splice(i, 1);
                this.count--;
                
                // 检查是否需要缩容
                if (this.limit > 7 && this.count < this.limit * 0.25) {
                    this.limit = Math.floor(this.limit / 2);
                    while (!this.isPrime(this.limit)) {
                        this.limit++;
                    }
                    this.resize(this.limit);
                }
                
                return v;
            }
        }
        
        return null;
    }
    
    // 调整哈希表大小
    resize(newLimit) {
        const oldStorage = this.storage;
        this.storage = [];
        this.limit = newLimit;
        this.count = 0;
        
        for (const bucket of oldStorage) {
            if (!bucket) continue;
            
            for (const [key, value] of bucket) {
                this.put(key, value);
            }
        }
    }
    
    // 获取哈希表大小
    size() {
        return this.count;
    }
    
    // 判断哈希表是否为空
    isEmpty() {
        return this.count === 0;
    }
}
```

## 哈希表的性能分析

- **时间复杂度**：
  - 平均情况：查找、插入、删除操作为O(1)
  - 最坏情况（所有键哈希到同一个位置）：O(n)

- **空间复杂度**：O(n)，其中n是存储的元素数量

哈希表的性能很大程度上取决于哈希函数的质量和哈希冲突的处理方式。一个好的哈希函数应该能够将键均匀地分布在哈希表中，减少冲突的发生。

## 哈希表的应用场景

1. **数据库索引**：用于快速查找数据记录
2. **缓存系统**：如浏览器缓存、Redis等
3. **编译器符号表**：存储变量和函数名
4. **网络路由**：存储IP地址与路由信息的映射
5. **用户认证**：存储用户名和密码的映射
6. **词频统计**：统计文本中单词出现的次数
7. **去重操作**：快速判断元素是否已存在

## 总结

哈希表是一种高效的数据结构，通过哈希函数将键直接映射到存储位置，实现了O(1)的平均时间复杂度的查找、插入和删除操作。本文实现的哈希表具有以下特点：

1. 使用链地址法解决哈希冲突
2. 动态调整数组大小，保持良好性能
3. 使用质数作为数组长度，优化哈希分布
4. 提供了完整的增删改查功能

哈希表在计算机科学和实际应用中有着广泛的应用，是每个程序员都应该掌握的重要数据结构。