# 链表的封装

链表是一种常见的数据结构，它通过节点之间的引用（或指针）连接形成链式结构。相比于数组，链表在插入和删除操作上具有更高的效率，不需要移动大量元素。本文将介绍如何在JavaScript中实现一个单链表。

## 链表的基本实现

以下是单链表的基本实现代码：

```javascript
// 链表的封装
function LinkedList() {
    // 封装节点类
    function Node(data) {
        this.data = data;
        this.next = null;
    }

    // 属性
    this.head = null;  // 头节点
    this.length = 0;   // 链表长度

    // 方法
    // 向链表尾部添加一个元素
    LinkedList.prototype.append = function (data) {
        // 创建元素
        let node = new Node(data);
        // 判断链表是否为空
        if (this.length == 0) {
            // 让head指向这个节点
            this.head = node;
        } else {
            // 链表不为空,让current指向第一个节点
            let current = this.head;
            // 判断current指向的节点的next是否为null
            while (current.next) {
                current = current.next;
            }
            // 指向null则将该节点的next指向node
            current.next = node;
        }
        this.length += 1;
    };

    // toString方法 - 将链表内容转为字符串
    LinkedList.prototype.toString = function () {
        let LinkedListString = '';
        let current = this.head;
        while (current) {
            LinkedListString += current.data + ' ';
            current = current.next;
        }
        return LinkedListString;
    };

    // insert方法 - 在指定位置插入元素
    LinkedList.prototype.insert = function (data, position) {
        // 判断position是否越界
        if (position < 0 || position > this.length) return false;
        // 创建节点
        let node = new Node(data);
        // 如果插入的是第0个位置
        if (position == 0) {
            node.next = this.head;
            this.head = node;
        } else {
            // 非第0个位置
            let current = this.head;
            let previous = null;
            let index = 0;
            while (index++ < position) {
                previous = current;
                current = current.next;
            }
            node.next = current;
            previous.next = node;
        }
        this.length += 1;
        return true;
    };

    // get方法 - 获取指定位置的元素
    LinkedList.prototype.get = function (position) {
        // 判断是否越界
        if (position < 0 || position >= this.length) return null;
        // 拿出数据
        let current = this.head;
        let index = 0;
        while (index++ < position) {
            current = current.next;
        }
        return current.data;
    };

    // indexOf方法 - 查找元素的位置
    LinkedList.prototype.indexOf = function (data) {
        let current = this.head;
        let index = 0;

        while (current) {
            if (current.data === data) {
                return index;
            }
            current = current.next;
            index += 1;
        }
        return -1;
    };

    // update方法 - 更新指定位置的元素
    LinkedList.prototype.update = function (data, position) {
        // 判断是否越界
        if (position < 0 || position >= this.length) return false;
        let current = this.head;
        let index = 0;
        while (index++ < position) {
            current = current.next;
        }
        current.data = data;
        return true;
    };

    // removeAt方法 - 移除指定位置的元素
    LinkedList.prototype.removeAt = function (position) {
        // 越界判断
        if (position < 0 || position >= this.length || position == undefined) return null;
        let index = 0;
        let previous = null;
        let current = this.head;
        // 若移除第0个位置的节点
        if (position == 0) {
            this.head = current.next;
        } else {
            while (index++ < position) {
                previous = current;
                current = current.next;
            }
            previous.next = current.next;
        }
        //长度变化，length-1
        this.length -= 1;
        return current.data;
    };

    // remove方法 - 移除指定元素
    LinkedList.prototype.remove = function (data) {
        // 获取位置
        return this.removeAt(this.indexOf(data));
    };

    // isEmpty方法 - 判断链表是否为空
    LinkedList.prototype.isEmpty = function () {
        return this.length == 0;
    };

    // size方法 - 获取链表长度
    LinkedList.prototype.size = function () {
        return this.length;
    };
}
```

## 链表的使用示例

以下是链表的基本使用示例：

```javascript
// 创建链表实例
let link = new LinkedList();

// 测试append方法
link.append(1);
link.append(2);
link.append(3);
link.append(4);
link.append(5);
console.log('初始链表:', link.toString());  // 输出: 1 2 3 4 5 

// 测试insert方法
link.insert(100, 3);  // 在索引为3的位置插入100
link.insert('aaa', 0);  // 在索引为0的位置插入'aaa'
console.log('插入元素后:', link.toString());  // 输出: aaa 1 2 3 100 4 5 

// 测试get方法
console.log('索引为2的元素:', link.get(2));  // 输出: 2

// 测试indexOf方法
console.log('元素100的索引:', link.indexOf(100));  // 输出: 4

// 测试update方法
link.update('bbb', 0);
console.log('更新第0个元素后:', link.toString());  // 输出: bbb 1 2 3 100 4 5 

// 测试removeAt方法
link.removeAt(4);
console.log('移除索引4的元素后:', link.toString());  // 输出: bbb 1 2 3 4 5 

// 测试remove方法
link.remove(2);
console.log('移除元素2后:', link.toString());  // 输出: bbb 1 3 4 5 

// 测试isEmpty和size方法
console.log('链表是否为空:', link.isEmpty());  // 输出: false
console.log('链表长度:', link.size());  // 输出: 5
```

## 更多测试用例

让我们增加一些额外的测试用例来验证链表的各种边界情况：

```javascript
// 测试边界情况
let emptyLink = new LinkedList();
console.log('空链表测试:');
console.log('isEmpty:', emptyLink.isEmpty());  // true
console.log('size:', emptyLink.size());  // 0
console.log('get(0):', emptyLink.get(0));  // null
console.log('insert(10, 0):', emptyLink.insert(10, 0));  // true
console.log('插入后的链表:', emptyLink.toString());  // 10 

// 测试移除最后一个元素
let singleLink = new LinkedList();
singleLink.append('only');
console.log('单元素链表移除后:', singleLink.removeAt(0));  // 'only'
console.log('移除后的链表是否为空:', singleLink.isEmpty());  // true

// 测试不存在的元素
console.log('移除不存在的元素:', link.remove('notExist'));  // null
console.log('查找不存在元素的索引:', link.indexOf('notExist'));  // -1
```

## 算法原理解析

### 链表的核心概念

链表是由节点组成的线性数据结构，每个节点包含两部分：
- **数据域**：存储节点的值
- **引用域**：存储指向下一个节点的引用

单链表的特点是只能从头到尾遍历，无法反向遍历。

### 各方法的实现原理

1. **append(data)**：向链表尾部添加元素
   - 创建新节点
   - 找到链表的最后一个节点（即next为null的节点）
   - 将最后一个节点的next指向新节点
   - 时间复杂度：O(n)，需要遍历整个链表找到尾部

2. **insert(data, position)**：在指定位置插入元素
   - 边界检查
   - 创建新节点
   - 找到插入位置的前一个节点
   - 修改引用关系完成插入
   - 时间复杂度：O(n)，最坏情况下需要遍历到链表尾部

3. **removeAt(position)**：移除指定位置的元素
   - 边界检查
   - 找到要移除节点的前一个节点
   - 修改引用关系跳过要移除的节点
   - 时间复杂度：O(n)，最坏情况下需要遍历到链表尾部

4. **get(position)** 和 **update(data, position)**：
   - 找到指定位置的节点
   - 执行读取或修改操作
   - 时间复杂度：O(n)

5. **indexOf(data)**：查找元素位置
   - 遍历链表比较每个节点的值
   - 时间复杂度：O(n)

## 性能分析

- **空间复杂度**：O(n)，需要存储n个节点
- **时间复杂度**：
  - 访问/查找元素：O(n)
  - 插入元素：O(n)（需要先找到插入位置）
  - 删除元素：O(n)（需要先找到删除位置）
  - 在链表头部插入/删除：O(1)

相比于数组，链表的优势在于不需要预先分配固定大小的空间，并且在任意位置插入和删除元素时不需要移动其他元素，但随机访问性能较差。

## ES6版本实现

下面是使用ES6语法实现的链表：

```javascript
class LinkedListES6 {
    constructor() {
        this.head = null;
        this.length = 0;
    }

    // 节点类
    Node = class {
        constructor(data) {
            this.data = data;
            this.next = null;
        }
    }

    // 向链表尾部添加元素
    append(data) {
        const node = new this.Node(data);
        
        if (this.length === 0) {
            this.head = node;
        } else {
            let current = this.head;
            while (current.next) {
                current = current.next;
            }
            current.next = node;
        }
        this.length++;
    }

    // 将链表内容转为字符串
    toString() {
        let result = '';
        let current = this.head;
        while (current) {
            result += current.data + ' ';
            current = current.next;
        }
        return result.trim();
    }

    // 在指定位置插入元素
    insert(data, position) {
        if (position < 0 || position > this.length) return false;
        
        const node = new this.Node(data);
        
        if (position === 0) {
            node.next = this.head;
            this.head = node;
        } else {
            let current = this.head;
            let previous = null;
            let index = 0;
            
            while (index++ < position) {
                previous = current;
                current = current.next;
            }
            
            node.next = current;
            previous.next = node;
        }
        
        this.length++;
        return true;
    }

    // 获取指定位置的元素
    get(position) {
        if (position < 0 || position >= this.length) return null;
        
        let current = this.head;
        let index = 0;
        
        while (index++ < position) {
            current = current.next;
        }
        
        return current.data;
    }

    // 查找元素的位置
    indexOf(data) {
        let current = this.head;
        let index = 0;
        
        while (current) {
            if (current.data === data) {
                return index;
            }
            current = current.next;
            index++;
        }
        
        return -1;
    }

    // 更新指定位置的元素
    update(data, position) {
        if (position < 0 || position >= this.length) return false;
        
        let current = this.head;
        let index = 0;
        
        while (index++ < position) {
            current = current.next;
        }
        
        current.data = data;
        return true;
    }

    // 移除指定位置的元素
    removeAt(position) {
        if (position < 0 || position >= this.length || position === undefined) return null;
        
        let current = this.head;
        let previous = null;
        let index = 0;
        
        if (position === 0) {
            this.head = current.next;
        } else {
            while (index++ < position) {
                previous = current;
                current = current.next;
            }
            previous.next = current.next;
        }
        
        this.length--;
        return current.data;
    }

    // 移除指定元素
    remove(data) {
        return this.removeAt(this.indexOf(data));
    }

    // 判断链表是否为空
    isEmpty() {
        return this.length === 0;
    }

    // 获取链表长度
    size() {
        return this.length;
    }
}
```
