---
date: 2025-09-20 21:04:31
title: 判断质数
permalink: /pages/39a386
categories:
  - src
  - 数据结构与算法
---

# 判断质数

质数（Prime Number）是指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。质数在数论和计算机科学中有着广泛的应用，如密码学、随机数生成和算法优化等领域。

本文将介绍几种判断一个数是否为质数的方法，并分析它们的时间复杂度。

## 一、基本概念

- **质数**：大于1的自然数，除了1和它本身外没有其他因数
- **合数**：大于1的自然数，除了1和它本身外还有其他因数
- **1**：既不是质数也不是合数

## 二、基础判断方法

### 算法原理

最直观的方法是从2开始，依次检查每个小于目标数的数是否能整除目标数。如果能找到一个能整除的数，则目标数不是质数；如果检查完所有可能的数都没有找到，则目标数是质数。

### 代码实现

```javascript
// 基础质数判断函数
function isPrime(number) {
    // 处理特殊情况
    if (number <= 1) return false; // 1不是质数
    if (number === 2 || number === 3) return true; // 2和3是质数
    
    // 从2开始，检查到number/2
    for (let i = 2; i <= Math.floor(number / 2); i++) {
        if (number % i === 0) {
            return false; // 找到因数，不是质数
        }
    }
    return true; // 没有找到因数，是质数
}

// 测试用例
console.log(isPrime(3));  // true
console.log(isPrime(9));  // false
console.log(isPrime(34)); // false
console.log(isPrime(54)); // false
console.log(isPrime(31)); // true
console.log(isPrime(37)); // true
console.log(isPrime(79)); // true
```

### 算法复杂度分析

- **时间复杂度**：O(n/2) = O(n)，其中n是要判断的数
- **空间复杂度**：O(1)，只使用了常数级别的额外空间

## 三、优化判断方法

### 算法原理

实际上，我们不需要检查到n/2，只需要检查到√n（n的平方根）即可。这是因为如果n有一个大于√n的因数d，那么n/d必定是一个小于√n的因数。

### 代码实现

```javascript
// 优化的质数判断函数
function isPrimeOptimized(number) {
    // 处理特殊情况
    if (number <= 1) return false; // 1不是质数
    if (number === 2 || number === 3) return true; // 2和3是质数
    if (number % 2 === 0 || number % 3 === 0) return false; // 排除所有偶数和3的倍数
    
    // 从5开始，检查到√number，步长为6（只需要检查形如6k±1的数）
    const sqrtNumber = Math.floor(Math.sqrt(number));
    for (let i = 5; i <= sqrtNumber; i += 6) {
        if (number % i === 0 || number % (i + 2) === 0) {
            return false; // 找到因数，不是质数
        }
    }
    return true; // 没有找到因数，是质数
}

// 测试用例
console.log(isPrimeOptimized(3));  // true
console.log(isPrimeOptimized(45)); // false
console.log(isPrimeOptimized(31)); // true
console.log(isPrimeOptimized(99)); // false
console.log(isPrimeOptimized(59)); // true
```

### 算法复杂度分析

- **时间复杂度**：O(√n/3) = O(√n)，其中n是要判断的数
- **空间复杂度**：O(1)，只使用了常数级别的额外空间

### 优化说明

这个优化版本包含了两个关键优化：
1. 只检查到√n，而不是n/2
2. 只检查形如6k±1的数，因为大于3的质数都可以表示为6k±1的形式

## 四、更高效的判断方法（Miller-Rabin素性测试）

对于非常大的数，我们可以使用概率性的素性测试算法，如Miller-Rabin测试，它可以在多项式时间内判断一个数是否为质数，并且错误率可以通过多次测试降到极低。

### 代码实现

```javascript
// Miller-Rabin素性测试（简化版）
function isPrimeMillerRabin(n, iterations = 5) {
    // 处理特殊情况
    if (n <= 1) return false;
    if (n <= 3) return true;
    if (n % 2 === 0) return false;
    
    // 写成n-1 = d*2^s
    let d = n - 1;
    let s = 0;
    while (d % 2 === 0) {
        d /= 2;
        s++;
    }
    
    // 进行iterations次测试
    for (let i = 0; i < iterations; i++) {
        // 随机选择a，满足2 <= a <= n-2
        const a = 2 + Math.floor(Math.random() * (n - 3));
        let x = modularPow(a, d, n);
        
        if (x === 1 || x === n - 1) continue;
        
        for (let j = 0; j < s - 1; j++) {
            x = modularPow(x, 2, n);
            if (x === n - 1) break;
        }
        
        if (x !== n - 1) return false;
    }
    
    return true;
}

// 快速幂取模
function modularPow(base, exponent, modulus) {
    if (modulus === 1) return 0;
    let result = 1;
    base = base % modulus;
    while (exponent > 0) {
        if (exponent % 2 === 1) {
            result = (result * base) % modulus;
        }
        exponent = exponent >> 1;
        base = (base * base) % modulus;
    }
    return result;
}

// 测试用例
console.log(isPrimeMillerRabin(3));      // true
console.log(isPrimeMillerRabin(1000000007)); // true (大质数)
console.log(isPrimeMillerRabin(1000000009)); // true (大质数)
console.log(isPrimeMillerRabin(1000000011)); // false
```

### 算法复杂度分析

- **时间复杂度**：O(k·log³n)，其中k是测试的迭代次数，n是要判断的数
- **空间复杂度**：O(1)，只使用了常数级别的额外空间

## 五、应用场景

质数在计算机科学和数学中有广泛的应用：

1. **密码学**：RSA加密算法基于大质数分解的困难性
2. **哈希表**：质数大小的哈希表可以减少冲突
3. **随机数生成**：许多随机数生成算法使用质数
4. **调度算法**：质数间隔可以避免周期性冲突
5. **数学研究**：质数分布和性质是数论的重要研究内容

## 六、总结

| 算法 | 时间复杂度 | 适用场景 | 特点 |
|------|------------|----------|------|
| 基础判断法 | O(n) | 小数 | 简单直观 |
| 优化判断法 | O(√n) | 中等大小的数 | 平衡了效率和复杂度 |
| Miller-Rabin | O(k·log³n) | 大数 | 概率性算法，适用于大数 |

在实际应用中，应根据需要判断的数的大小选择合适的算法。对于日常编程中遇到的大多数情况，优化的O(√n)算法已经足够高效。