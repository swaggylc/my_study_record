---
date: 2025-09-23 22:45:10
title: 地址栏输入 URL 敲下回车后发生了什么
permalink: /pages/fc4fd9
categories:
  - src
  - 浏览器和网络
---

# 地址栏输入 URL 敲下回车后发生了什么

当用户在浏览器地址栏输入 URL 并按下回车时，看似简单的操作背后隐藏着一系列复杂的过程。主要可以分为两个部分，网络部分和渲染部分，下面我们将详细解析这个完整流程。                         
[点我跳转：浏览器渲染原理](./d1f2a7)

## 1. URL 解析与验证【<span class="marker-evy">网络部分</span>】

浏览器首先对输入的 URL 进行解析和标准化处理：

- **检查格式**：判断输入的是 URL 还是搜索关键词。如果格式不完整（如缺少 `http://` 或 `https://`），浏览器会自动补全。
- **提取信息**：解析出协议（如 `https`）、域名（如 `www.example.com`）、端口号（默认 80 或 443）、路径（如 `/index.html`）和查询参数等。
- **安全策略检查**：检查 HSTS（HTTP Strict Transport Security）列表，强制使用 HTTPS。

## 2. DNS 解析（域名 → IP 地址）

由于网络通信需要 IP 地址，浏览器必须将域名转换为对应的 IP 地址。这个过程称为 DNS 解析，其查找顺序如下：

1. **浏览器缓存**（如 Chrome 内部缓存）
2. **操作系统缓存**
3. **路由器缓存**
4. **ISP（互联网服务提供商）的 DNS 服务器**
5. **递归查询**：如果仍未找到，则进行递归查询 - 根域名服务器 → 顶级域（如 `.com`）→ 权威 DNS 服务器

解析结果会被缓存，以加速后续访问。

## 3. 建立 TCP 连接（三次握手）

获取 IP 地址后，浏览器通过 TCP 协议与服务器建立可靠的连接：

```
三次握手过程：
1. 客户端发送 SYN（同步）
2. 服务器回复 SYN-ACK（同步-确认）
3. 客户端发送 ACK（确认）
```

此时，TCP 连接建立成功。

### HTTPS 网站的额外步骤：TLS/SSL 握手

如果是 HTTPS 网站，还需进行 TLS/SSL 握手以建立安全连接：

1. 协商加密算法
2. 服务器发送数字证书（由 CA 认证机构签发）
3. 验证证书有效性
4. 通过非对称加密交换对称密钥
5. 建立安全加密通道

## 4. 发送 HTTP 请求

TCP（或 TLS）连接建立后，浏览器构造并发送 HTTP 请求报文：

```http
请求行：如 GET /index.html HTTP/1.1
请求头：包含 Host、User-Agent、Accept、Cookie 等信息
请求体（可选）：如 POST 请求中的表单数据
```

现代浏览器可能使用 HTTP/2 或 HTTP/3（基于 QUIC），支持多路复用、降低延迟。

## 5. 服务器处理请求

服务器接收到请求后：

1. **负载均衡**：请求可能先到达反向代理（如 Nginx），再转发给后端应用服务器。
2. **业务处理**：执行后端逻辑（如数据库查询、调用 API、运行 PHP/Node.js 等脚本）。
3. **生成响应**：构建 HTTP 响应报文，包括状态码（如 200 OK、404 Not Found）、响应头和响应体（通常是 HTML 内容）。

## 6. 浏览器接收响应并解析渲染【<span class="marker-evy">渲染部分</span>】

浏览器收到服务器返回的 HTML 文档后，开始渲染页面，流程如下：

### 6.1 构建 DOM 树
解析 HTML 文本，通过词法分析生成 Tokens，再构建 DOM（Document Object Model）树。

### 6.2 构建 CSSOM 树
解析 CSS（内联、外部、内部样式），生成 CSSOM（CSS Object Model）树，包含每个元素的最终样式。

### 6.3 生成渲染树（Render Tree）
将 DOM 和 CSSOM 结合，生成只包含可见元素的渲染树（如 `display: none` 的元素不包含在内）。

### 6.4 布局（Layout / Reflow）
计算每个渲染树节点的几何信息（位置、尺寸）。

### 6.5 分层（Layering）
根据 `z-index`、`transform`、`opacity` 等属性将页面分层，便于后续高效更新。

### 6.6 绘制（Painting）、分块（Tiling）与光栅化（Rasterization）
生成绘制指令，将图层划分为图块（tiles）。
合成线程将图块交给 GPU 进行光栅化（转换为位图）。

### 6.7 合成与显示（Compositing）
GPU 将各图层的位图合成，最终输出到屏幕。

> 🌟 **注意**：此过程中，遇到 `<script>` 标签会阻塞 DOM 解析（除非使用 `async` 或 `defer`）；而 CSS 虽不阻塞 HTML 解析，但会阻塞渲染（避免 FOUC - 无样式内容闪现）。

## 7. 加载额外资源

浏览器继续解析 HTML，发现 `<img>`、`<link rel="stylesheet">`、`<script>` 等标签后，会发起额外的 HTTP 请求来加载图片、CSS、JavaScript 等资源。

## 8. 执行 JavaScript

下载并执行 JS 脚本，可能修改 DOM/CSSOM，触发重排（reflow）或重绘（repaint）。
JS 是单线程执行，异步加载（`async`、`defer`）可优化性能。

## 9. 连接关闭（四次挥手）

数据传输完成后，TCP 连接通过四次挥手断开：

```
四次挥手过程：
1. 客户端发送 FIN
2. 服务器回复 ACK
3. 服务器发送 FIN
4. 客户端回复 ACK
```

实际中，连接可能被保持（Keep-Alive）以复用，减少后续请求的延迟。

## 总结：一句话流程

```
                          输入 URL
                             ⬇
                          解析与验证
                             ⬇
                          DNS 查询
                             ⬇
                          TCP 三次握手
                             ⬇
                      （HTTPS 则 TLS 握手）
                             ⬇
                          发送 HTTP 请求
                             ⬇
                          服务器处理
                             ⬇
                          返回响应
                             ⬇
                          浏览器渲染（DOM + CSSOM → 渲染树 → 布局 → 绘制 → 合成）
                             ⬇
                          加载资源
                             ⬇
                          执行 JS
                             ⬇
                          页面可交互
```

## 🚀 开发优化建议

理解这一过程有助于性能优化：

- **DNS 预解析**：`<link rel="dns-prefetch" href="//example.com">`
- **资源预加载**：`<link rel="preload">`
- **CDN 加速**：缩短用户与服务器的物理距离
- **懒加载（Lazy Load）**：延迟加载非首屏图片
- **启用缓存**：合理设置 Cache-Control、ETag
- **代码分割**：减少首屏加载体积

整个过程涉及网络、操作系统、浏览器内核、安全、渲染等多个领域，是现代 Web 技术协同工作的典范。