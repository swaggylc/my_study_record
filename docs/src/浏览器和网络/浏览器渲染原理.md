---
date: 2025-09-20 20:25:54
title: 浏览器渲染原理
permalink: /pages/d1f2a7
categories:
  - src
  - 浏览器和网络
---

# 浏览器渲染原理详解

浏览器的渲染过程是前端性能优化的核心基础，了解这一过程有助于我们编写出更高效、响应更快的Web应用。本文将详细解析浏览器从接收到HTML、CSS和JavaScript等资源到最终在屏幕上呈现出页面的完整过程。

## 一、浏览器渲染流程图

![浏览器渲染过程](/img/浏览器和网络/浏览器渲染原理/浏览器渲染过程.png)

## 二、渲染过程详解

### 1. HTML解析与DOM树构建

当浏览器接收到HTML文档后，渲染引擎会逐行解析HTML代码，将标签转换为DOM树中的节点。这个过程是增量的，浏览器会尽可能早地展示内容，而不必等到整个HTML文档解析完毕。

```
HTML 文档 -> 词法分析 -> 语法分析 -> DOM树
```

**关键特点：**
- 自上而下，逐行解析
- 遇到CSS和JavaScript资源会触发并行加载
- 遇到`<script>`标签可能会阻塞DOM解析（取决于脚本类型和属性）

### 2. CSS解析与CSSOM树构建

同时，浏览器会解析页面中的CSS样式，构建CSS对象模型（CSSOM）。CSSOM是一个包含页面所有样式信息的树状结构，每个节点都有对应的样式属性。

```
CSS 资源 -> 词法分析 -> 语法分析 -> CSSOM树
```

**CSS优先级规则：**
- `!important` > 内联样式 > ID选择器 > 类选择器/属性选择器/伪类选择器 > 标签选择器 > 通配符选择器 > 继承样式
- 相同优先级时，后定义的样式会覆盖先定义的样式

### 3. 渲染树(Render Tree)构建

DOM树和CSSOM树构建完成后，浏览器会将两者结合，生成渲染树（Render Tree）。渲染树只包含可见的元素和它们的样式信息，不可见元素（如`display: none`的元素）不会被包含在渲染树中。

```
DOM树 + CSSOM树 -> 筛选可见元素 -> 计算样式 -> 渲染树
```

**渲染树与DOM树的区别：**
- 渲染树只包含可见元素
- 渲染树中的节点可能与DOM树不同（如伪元素会在渲染树中体现）
- 每个渲染树节点都包含样式信息

### 4. 布局(Layout)

布局阶段，浏览器会计算渲染树中每个节点的精确位置和大小，这一过程也被称为"重排"(Reflow)。浏览器从根节点开始，递归地计算每个节点的几何信息。

```
渲染树 -> 计算节点位置和大小 -> 布局树
```

**触发重排的常见操作：**
- 添加、删除、修改DOM元素
- 修改元素的位置、尺寸、内容
- 滚动页面
- 改变浏览器窗口大小

### 5. 绘制(Painting)

布局完成后，浏览器会遍历渲染树，将每个节点绘制到屏幕上。这一过程涉及将每个元素的视觉属性（如颜色、边框、阴影等）转换为像素。

```
布局树 -> 遍历渲染树 -> 转换为像素 -> 绘制到屏幕
```

**绘制顺序：**
- 背景色
- 背景图
- 边框
- 子元素
- 轮廓

### 6. 合成(Compositing)与合成线程

合成是渲染过程的最后一个阶段，由专门的**合成线程**负责执行。合成线程的主要工作是将页面拆分为多个层，然后将这些层合成为一个完整的页面。这种技术可以显著提高渲染性能，特别是在处理动画和滚动效果时。

#### 合成线程的工作过程

合成线程的工作流程主要包括以下几个关键步骤：

1. **分层判断与层树构建**
   合成线程会分析渲染树，根据元素的特性（如`position`、`opacity`、`transform`等）决定哪些元素应该创建新的层。然后，合成线程会构建一个层树（Layer Tree），表示页面中所有层的层级关系。

2. **层的绘制命令生成**
   对于每个层，合成线程会生成绘制命令列表，但并不会立即执行绘制操作。

3. **栅格化（Rasterization）**
   栅格化是将绘制命令转换为实际像素的过程。合成线程会将层划分为多个图块（Tiles），通常为256x256或512x512像素大小，然后将这些图块分配给多个栅格化线程并行处理。
   
   > 注意：栅格化过程通常会优先处理视口内的图块，以及视口附近可能很快进入视口的图块。

4. **GPU合成**
   所有图块栅格化完成后，合成线程会收集每个图层的绘制信息（包括图层的位置、透明度等），并将这些信息组装成一个绘制四边形的命令列表，然后发送给GPU。

5. **页面显示**
   GPU接收到命令后，会将所有图层按照正确的顺序绘制到屏幕上，最终呈现出完整的页面。

```
渲染树 -> 分层处理 -> 层树构建 -> 生成绘制命令 -> 栅格化 -> GPU合成 -> 最终显示
```

#### 合成的优势

- **避免重排和重绘**：当只改变元素的`transform`和`opacity`属性时，浏览器可以只执行合成操作，而不需要重新布局和绘制，大大提高了性能
- **并行处理**：栅格化过程可以由多个线程并行处理，充分利用多核CPU
- **GPU加速**：合成操作主要由GPU执行，效率更高
- **滚动优化**：浏览器可以为滚动内容创建单独的层，实现更流畅的滚动体验

#### 适合创建新层的情况

- 元素有3D变换或透视效果
- 元素有动画或过渡效果
- 元素有`will-change`属性
- 元素有`z-index`且位于较高层次
- 元素有`opacity`动画
- 滚动容器或滚动内容

## 三、渲染性能优化策略

基于浏览器的渲染过程，我们可以采取以下策略来优化Web页面的渲染性能：

### 1. 减少DOM操作

- 使用文档片段(DocumentFragment)批量处理DOM
- 避免频繁查询DOM，使用变量缓存查询结果
- 考虑使用虚拟DOM技术

### 2. 优化CSS性能

- 简化选择器，避免使用复杂的后代选择器
- 避免使用`@import`，优先使用`<link>`标签
- 合理使用CSS预处理器
- 启用CSS压缩和合并

### 3. 优化JavaScript执行

- 将JavaScript脚本放在页面底部
- 使用`defer`和`async`属性优化脚本加载
- 减少DOM操作，避免频繁触发重排和重绘
- 合理使用`requestAnimationFrame`处理动画

### 4. 利用浏览器缓存

- 设置合适的HTTP缓存策略
- 使用Service Worker实现离线缓存
- 考虑使用CDN分发静态资源

## 四、关键概念解析

### 1. 重排(Reflow)与重绘(Repaint)

- **重排**：当元素的几何属性（位置、大小）发生变化时，浏览器需要重新计算元素的布局，这一过程称为重排
- **重绘**：当元素的视觉属性（颜色、背景）发生变化，但几何属性不变时，浏览器只需要重新绘制元素，这一过程称为重绘
- **性能消耗**：重排 > 重绘 > 合成

### 2. 渲染阻塞

- **CSS阻塞**：CSS会阻塞渲染树的构建，影响页面的首次绘制
- **JavaScript阻塞**：JavaScript会阻塞DOM解析，也可能阻塞CSSOM构建
- **优化方法**：使用媒体查询、异步加载非关键CSS；延迟加载非关键JavaScript

### 3. 关键渲染路径(Critical Rendering Path)

关键渲染路径是指浏览器将HTML、CSS和JavaScript转换为可见像素的最短路径。优化关键渲染路径可以显著提高页面的加载速度和首次绘制时间。

## 五、总结

浏览器渲染过程是一个复杂而精密的系统，涉及HTML解析、CSS解析、渲染树构建、布局、绘制和合成等多个阶段。了解这一过程，有助于我们编写出性能更优的前端代码，提升用户体验。在实际开发中，我们应该关注关键渲染路径的优化，减少重排和重绘，合理利用浏览器的渲染机制。

通过本文的学习，相信你对浏览器渲染原理有了更深入的理解，在今后的前端开发中，能够更好地应用这些知识，构建高性能的Web应用。